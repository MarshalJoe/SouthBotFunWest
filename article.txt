# Building @SouthBotFunWest, a Twitterbot that Recommends SXSW Parties (Node + Twit)

It's that time of year, when a product manager's thoughts turn to daydrinking and the streets of Austin are turned into a bacchanalia of technology celebrating the almighty God of the Internet &mdash; SXSW Interactive!

SXSW has been the launching ground for many web businesses that have to gone on to both small and large fame, but none of them can hold a candle to SXSW's own true prodigal son, Twitter, a technology that didn't even launch at the event &mdash; it actually [debuted 9 months earlier](http://mashable.com/2011/03/05/sxsw-launches/) &mdash; but became so popular at the 2008 festival that its fortunes became indelibly associated with the conference.

Twitter has vast appeal as a data source because it's 140-character snippets (and photos) provide an astonishing amount of insight into popular sentiment &mdash; part of the reason it's currently being [archived for future generations](http://www.cnn.com/2010/TECH/04/14/library.congress.twitter/) by the Library of Congress. Twitter is also a fantastic source for programmatic content: NASA has a twitter handle for posting high-definition images from the Hubble Space Telescope daily ([@HubbleDaily](https://twitter.com/hubbledaily)), which proves just about *everyone* is getting on board the twitterbot bandwagon.

With that in mind, let's use Node, everyone's favorite server-side Javascript solution, and `twit`, an npm package that taps into both the streaming and RESTful Twitter APIs, to build a bot that can harness the collective hipness of the twitterati to provide that elusive social shibboleth &mdash; the perfect SXSW party recommendation.

If you haven't already, [install Node and npm](), Node's fantastic package manager. When you've confirmed that they're in your path (an easy way to check is `which node` and `which npm`), create a directory for your project and navigate into it: We'll do this with `mkdir SouthBotFunWest && cd SouthBotFunWest`

Next start a new Node project with `npm init`. You'll be prompted to enter a name and some other particulars, but if you prefer you can just `enter` through every thing.

Now down to business! Our first and only dependency for this project will be `twit`, a Node module for working with the Twitter API. Use the following command to install the module and save it to your `package.json` in one go:

`npm install --save twit`

(If you're getting some weird warnings installing the packages, add `'private': true` to your `package.json` to get rid of them.)

At this point, you'll need to create a twitter profile (in my case, [@SouthBotFunWest]()) and link it to an associated developer account, which you can create at [dev.twitter.com/apps](). After you've created and linked your accounts, make note of your consumer key and secret, and click "generate access tokens."

In your root directory, create a `config.js` file to store these Twitter secret keys and access tokens. Add this to your `.gitignore` file (if you haven't made one yet, there's no time like the present). Your `config.js` should look like this:

````javascript
module.exports = {
    consumer_key: "",
    consumer_secret: "",
    access_token: "",
    access_token_secret: ""
}
````
(Except with actual keys and tokens!)

You might notice that this is different than how the API documentation describes inputting your consumer and access keys/tokens, that we're abstracting our Twitter credentials into a separate file. We've done this for the purpose of keeping it secure. By keeping sensitive credentials in a separate file that we can add to our `.gitignore`, we can keep from committing that information to a public repo, which would be [very bad]().

To test our Twitter API access, let's slightly modify one of the twit boilerplate examples to post a classic "hello world!" message. The new `index.js` should look like this.

````javascript
var Twit = require('twit');
var twitInfo = require('./config.js');

var twitter = new Twit(twitInfo);

twitter.post('statuses/update', { status: 'hello world!' }, function(err, data, response) {
  console.log(data);
});
````
Remember how earlier we talked about abstracting our sensitive credentials into a separate `config.js` file? They key to making that work is the `require()` function's ability to import javascript files. Using `require('./config.js')` we can make accessible the config object exported inside of it and pass it along as an argument to the `new Twit` constructor function. We know what the `Twit` constructor function is expecting, which is why the `config.js` file has been written so that the attribute names are consistent with the `twit` API.

Start the bot with `node index.js`. You should see the data object associated with your tweet logged to the terminal and if you go to your Twitter profile, you should see those familiar two words!

Now let's try some boilerplate a little more suited to our current purposes &mdash; searching tweets.

````javascript
twitter.get('search/tweets', { q: 'banana since:2011-11-11', count: 100 }, function(err, data, response) {
  console.log(data)
})
````
That's a lot of objects! To make some sense of the structure by printing out all the top-level attributes, change `console.log(data)` to:

````javascript
for (attr in data) {
    console.log(attr);
}
````

`statuses` looks like what we want. Exploring that a little further, we can see that it consists of an array of tweet objects. Let's modify our code to print out the text of all those tweets.

````javascript
var Twit = require('twit');
var twitInfo = require('./config.js');
var twitter = new Twit(twitInfo);

var tweets;

twitter.get('search/tweets', { q: 'banana since:2011-11-11', count: 100 }, function(err, data, response) {
  tweets = data.statuses;
  for (index in tweets) {
    console.log(tweets[index].text);
  }
})
````

That is a *lot* of banana talk. Now on to SXSW!

There are a few different ways one could go about writing a script that responds to tweeted questions with SXSW event recommendations. In order to *find* the parties, we could write something that culled info from event websites via [PhantomJS](), we could use the API of a social network like Reddit to find party leads, or we could query a search engine hoping to find the actual RSVP pages of some honest-to-goodness soirees. 

But ultimately the best solution that results in the neatest stack, clearest separation of concerns, and returns the results we want is right in front of our faces &mdash; the Twitter search API.

The following code puts that theory to the test. Using some pretty direct searches, let's see if we can return some links to the types of parties we're after.

````javascript
var Twit = require('twit');
var twitInfo = require('./config.js');

var twitter = new Twit(twitInfo);

var musicParties, 
        interactiveParties, 
        filmParties;


twitter.get('search/tweets', { q: 'SXSW music party ', count: 100 }, function(err, data, response) {
  musicParties = data.statuses;
  console.log("MUS " + musicParties[0].text);
})

twitter.get('search/tweets', { q: 'SXSW interactive party ', count: 100 }, function(err, data, response) {
  interactiveParties = data.statuses;
  console.log("INT " + interactiveParties[0].text);
})

twitter.get('search/tweets', { q: 'SXSW film party ', count: 100 }, function(err, data, response) {
  filmParties = data.statuses;
  console.log("FLM " + filmParties[0].text);
})
````
When the new `index.js` is run, it produces the following output:

````
FLM RT @NGeistofficial: Salem to host 2015 #SXSW Film Festival opening #party http://t.co/ytDINxCflW #SXSW2015 #SXSWFilm #Salem @SalemWGNA http…

INT RT @Skoop_Events: North of 41 - 5th Annual SxSW Interactive Party
March 14, 8-11:30pm
RSVP: http://t.co/DZWA9osAIG
/#sxsw15 #sxsw #sxsw2015 …

MUS Yuuuhhh "@austin360: Ghostface Killah headlines another SXSW party http://t.co/MiAO81rxVm" @sinhalesepolice in atx for sxsw?
````

Those look like things we want. 

That was a sample of searches intended to aggregate a large database of tweets, that we could then analyze and tweet to people asking for specific types of parties.

But what's the *largest* database of tweets? Twitter!

Let's refactor our approach to rely on a one-for-one search as opposed to a data aggregation stategy &mdash; which can get messy and requires a sizeable back-end. Taking this tack, here's a more generalized twitter search function:

````javascript
function search (query) {
    twitter.get('search/tweets', { q: query, count: 1 }, function(err, data, response) {
      console.log(data.statuses[0].text);
    })
}
`````
Logging `data.statuses[0].text` is a stand-in right now for when we'll post the tweet later.

Testing this code out with `search('SXSW music party')` we return the same result as the music party tweet mentioned before.

That's all a good start! Now let's get to work on the responding-to-users part of the twitterbot, which will require the streaming API functionality of our `twit` client.

Looking at the API, it seems simple enough to open a stream tracking mentions of a specific word. In our case, since we want to track people who are tweeting at the bot, it makes sense to track the current handle, @SouthBotFunWest. Here's the code to open a stream tracking our mentions logging both the tweets and their posters.

````javascript
var stream = twitter.stream('statuses/filter', { track: '@SouthBotFunWest' });

stream.on('tweet', function (tweet) {
  var asker = tweet.user.screen_name;
  var text = tweet.text;
  console.log(asker + " tweeted: " + text);
})
````

Log out of your bot's profile (if you're logged in of course), log in to another, tweet at your bot and check back at your terminal. You should see your name and tweet logged on the command line!

Now we've got the ability to track (and presumably, respond to, once we implement posting) tweets that mention our bot. The next logical step is putting in place a system to trigger different search queries depending on the content of those tweets.







